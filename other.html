<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Check .keras file inspector & TF.js loader</title>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.14.0/dist/tf.min.js"></script>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; padding: 18px; max-width: 980px; margin: auto; }
    h1 { font-size: 20px; margin-bottom: 6px; }
    .panel { border: 1px solid #ddd; border-radius: 8px; padding: 12px; margin: 10px 0; background:#fafafa; }
    table { width:100%; border-collapse:collapse; font-size:13px; }
    th, td { text-align:left; padding:6px; border-bottom: 1px solid #eee; }
    pre { white-space:pre-wrap; background:#111; color:#eee; padding:8px; border-radius:6px; overflow:auto; max-height:280px;}
    .ok { color: #0a0; font-weight:600; }
    .err { color: #b00; font-weight:600; }
    button { padding:8px 12px; border-radius:6px; border:1px solid #888; background:white; cursor:pointer; }
  </style>
</head>
<body>
  <h1>Inspect & Test a <code>.keras</code> file</h1>
  <p>Upload your <code>best_tamper_model.keras</code> file. The page will list its contents and — if it contains a TensorFlow.js <code>model.json</code> and weight shards — attempt to load it in the browser.</p>

  <div class="panel">
    <input id="fileInput" type="file" accept=".keras,.zip" />
    <button id="btnClear">Clear</button>
    <div id="status" style="margin-top:8px"></div>
  </div>

  <div id="contents" class="panel" style="display:none">
    <h3>Archive contents</h3>
    <table id="fileTable"><thead><tr><th>Path</th><th style="width:120px">Size</th></tr></thead><tbody></tbody></table>

    <div id="jsonPreview" style="margin-top:12px"></div>

    <div id="tfjsSection" style="margin-top:12px"></div>

    <div id="modelSummary" style="margin-top:12px"></div>
  </div>

  <script>
    const fileInput = document.getElementById('fileInput');
    const status = document.getElementById('status');
    const contents = document.getElementById('contents');
    const fileTableBody = document.querySelector('#fileTable tbody');
    const jsonPreview = document.getElementById('jsonPreview');
    const tfjsSection = document.getElementById('tfjsSection');
    const modelSummary = document.getElementById('modelSummary');
    const btnClear = document.getElementById('btnClear');

    btnClear.onclick = () => {
      fileInput.value = "";
      contents.style.display = 'none';
      status.innerText = "";
      fileTableBody.innerHTML = "";
      jsonPreview.innerHTML = "";
      tfjsSection.innerHTML = "";
      modelSummary.innerHTML = "";
    };

    function humanSize(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024*1024) return (bytes/1024).toFixed(1) + ' KB';
      return (bytes/1024/1024).toFixed(2) + ' MB';
    }

    fileInput.addEventListener('change', async (ev) => {
      const file = ev.target.files[0];
      if (!file) return;
      status.innerHTML = `Reading <strong>${file.name}</strong> (${humanSize(file.size)}) ...`;
      fileTableBody.innerHTML = "";
      jsonPreview.innerHTML = "";
      tfjsSection.innerHTML = "";
      modelSummary.innerHTML = "";
      contents.style.display = 'none';

      try {
        const arrayBuffer = await file.arrayBuffer();
        let zip;
        try {
          zip = await JSZip.loadAsync(arrayBuffer);
        } catch (e) {
          status.innerHTML = `<span class="err">Not a zip archive or corrupted (.keras is usually a zip). Error: ${e.message || e}</span>`;
          return;
        }

        const entries = [];
        zip.forEach((relativePath, zipEntry) => {
          entries.push({ path: relativePath, size: zipEntry._data ? zipEntry._data.uncompressedSize : zipEntry._dataLength || zipEntry._length || 0 });
        });

        // Sort by path
        entries.sort((a,b) => a.path.localeCompare(b.path));
        for (const e of entries) {
          const tr = document.createElement('tr');
          tr.innerHTML = `<td><code>${e.path}</code></td><td>${humanSize(e.size || 0)}</td>`;
          fileTableBody.appendChild(tr);
        }

        contents.style.display = 'block';
        status.innerHTML = `<span class="ok">Archive opened — ${entries.length} file(s) found.</span>`;

        // Try to show metadata/json files if present
        const prettyShow = async (path) => {
          try {
            const txt = await zip.file(path).async('string');
            const parsed = JSON.parse(txt);
            return `<h4>${path}</h4><pre>${JSON.stringify(parsed, null, 2).slice(0, 3000)}</pre>`;
          } catch (err) {
            // fallback: raw text
            try {
              const txt = await zip.file(path).async('string');
              return `<h4>${path}</h4><pre>${txt.slice(0,3000)}</pre>`;
            } catch (e) {
              return '';
            }
          }
        };

        // Common metadata names in .keras/zips
        const metadataNames = ['metadata.json', 'keras_metadata.json', 'model_metadata.json', 'model.json', 'saved_model.pb', 'model_config.json', 'keras_metadata.json', 'model_metadata.json'];
        for (const name of metadataNames) {
          if (zip.file(name)) {
            const html = await prettyShow(name);
            jsonPreview.innerHTML += html;
          }
        }

        // If TF.js model.json exists inside the zip, attempt to load with tfjs.
        if (zip.file('model.json')) {
          tfjsSection.innerHTML = `<h3>Detected <code>model.json</code> — attempting to load with TensorFlow.js...</h3><div id="tfjsStatus">Preparing...</div>`;
          const tfjsStatus = document.getElementById('tfjsStatus');

          try {
            const modelJsonText = await zip.file('model.json').async('string');
            const modelJson = JSON.parse(modelJsonText);

            // Collect weight paths referenced by model.json (layers model uses weightsManifest)
            let weightPaths = [];
            if (modelJson.weightsManifest && Array.isArray(modelJson.weightsManifest)) {
              for (const manifest of modelJson.weightsManifest) {
                if (manifest.paths && Array.isArray(manifest.paths)) {
                  weightPaths.push(...manifest.paths);
                }
              }
            }

            // Build files array (model.json first), then the weight shard files in the same order as manifest
            const fileObjs = [];

            // model.json blob/file
            const modelJsonBlob = new Blob([modelJsonText], { type: 'application/json' });
            const modelJsonFileObj = new File([modelJsonBlob], 'model.json', { type: 'application/json' });
            fileObjs.push(modelJsonFileObj);

            // For every referenced weight path, find it in zip and add
            let missing = [];
            for (const p of weightPaths) {
              // model.json weight paths may be relative. We'll search for an exact match or for last path segment.
              let entry = zip.file(p) || zip.file(p.replace(/^\.\/+/, '')) || null;
              if (!entry) {
                // search by basename
                const basename = p.split('/').pop();
                entry = Object.values(zip.files).find(f => f.name.split('/').pop() === basename);
              }
              if (!entry) {
                missing.push(p);
                continue;
              }
              const blob = await entry.async('arraybuffer');
              const f = new File([blob], entry.name, { type: 'application/octet-stream' });
              fileObjs.push(f);
            }

            if (missing.length) {
              tfjsStatus.innerHTML = `<span class="err">Missing weight shards listed in model.json: ${missing.map(x=>'<code>'+x+'</code>').join(', ')}. Cannot load model unless shards are present.</span>`;
            } else {
              tfjsStatus.innerHTML = `All referenced shards found; attempting tf.loadLayersModel(...) — this may take a few seconds.`;
              // Attempt to load
              try {
                const model = await tf.loadLayersModel(tf.io.browserFiles(fileObjs));
                tfjsStatus.innerHTML = `<span class="ok">Model loaded successfully with TensorFlow.js!</span>`;

                // Build a readable summary
                const lines = [];
                lines.push(`<h3>Model summary</h3>`);
                lines.push(`<p><strong>Name:</strong> ${model.name || '—'}</p>`);
                try {
                  const totalParams = model.countParams ? model.countParams() : (model.weights ? model.weights.length : 'unknown');
                  lines.push(`<p><strong>Total params:</strong> ${totalParams}</p>`);
                } catch (e) {}
                lines.push(`<table><thead><tr><th>Layer</th><th>Type</th><th>Output shape</th><th>Params</th></tr></thead><tbody>`);
                for (const layer of model.layers) {
                  const lname = layer.name || '';
                  const ltype = layer.getClassName ? layer.getClassName() : (layer.constructor && layer.constructor.name) || 'Layer';
                  let outShape = '';
                  try {
                    outShape = JSON.stringify(layer.outputShape);
                  } catch (e) { outShape = String(layer.outputShape); }
                  let pcount = '?';
                  try { pcount = (typeof layer.countParams === 'function') ? layer.countParams() : (layer.weights ? layer.weights.length : '?'); } catch(e){}
                  lines.push(`<tr><td><code>${lname}</code></td><td>${ltype}</td><td><code>${outShape}</code></td><td>${pcount}</td></tr>`);
                }
                lines.push(`</tbody></table>`);
                modelSummary.innerHTML = lines.join('\n');

                // Optionally run a tiny predict sanity test if the model has an input shape that we can fill with zeros.
                try {
                  const inputShapes = model.inputs && model.inputs.map(i => i.shape);
                  if (inputShapes && inputShapes.length > 0) {
                    // make a zero tensor matching first input shape (replace null/dim batch with 1)
                    const s = inputShapes[0].map(d => d === null ? 1 : d);
                    if (s.every(d => typeof d === 'number' && d > 0 && Number.isFinite(d) && d < 1e6)) {
                      tfjsStatus.innerHTML += `<div>Attempting a quick inference with zeros for input shape ${JSON.stringify(inputShapes[0])} ...</div>`;
                      const sample = tf.zeros(s);
                      const out = model.predict(sample);
                      // convert to shape info
                      let outInfo = 'prediction ok';
                      if (Array.isArray(out)) {
                        outInfo = out.map(o => o.shape ? `shape ${JSON.stringify(o.shape)}` : 'tensor').join(', ');
                      } else if (out && out.shape) {
                        outInfo = `shape ${JSON.stringify(out.shape)}`;
                      }
                      tfjsStatus.innerHTML += `<div class="ok">Quick inference succeeded — output: ${outInfo}</div>`;
                      // dispose
                      sample.dispose();
                      if (out && out.dispose) out.dispose();
                    } else {
                      tfjsStatus.innerHTML += `<div>Input shape has variable/large dims; skipping automatic test.</div>`;
                    }
                  } else {
                    tfjsStatus.innerHTML += `<div>No model.inputs found; skipping quick inference test.</div>`;
                  }
                } catch (infErr) {
                  tfjsStatus.innerHTML += `<div class="err">Quick inference failed: ${infErr.message || infErr}</div>`;
                }

              } catch (loadErr) {
                tfjsStatus.innerHTML = `<span class="err">tf.loadLayersModel failed: ${loadErr.message || loadErr}</span>`;
              }
            }
          } catch (err) {
            tfjsSection.innerHTML = `<div class="err">Error processing model.json: ${err.message || err}</div>`;
          }
        } else {
          // No model.json present — show helpful hint
          tfjsSection.innerHTML = `<h3>No TensorFlow.js <code>model.json</code> found inside the archive.</h3>
            <p>It likely contains Keras SavedModel-style files (Keras v3 <code>.keras</code> zip). You can still inspect other metadata files shown above.</p>
            <p>If your goal is to run this model in the browser, convert it to TensorFlow.js format with the converter (on a machine with Python/TensorFlow):</p>
            <pre>python -m tensorflowjs_converter --input_format=keras saved_model_folder tfjs_target_dir</pre>
            <p>or save a TF.js compatible <code>model.json</code> + shards from Python before using in the browser.</p>`;
        }

      } catch (err) {
        status.innerHTML = `<span class="err">Error: ${err.message || err}</span>`;
      }
    });
  </script>
</body>
</html>
